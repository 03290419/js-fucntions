# Functions

프로그래밍 언어의 함수는 `일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행단위로 정의한 것이다.`

함수는 객체 타입의 값으로 식별자를 붙일 수 있다.

## Function Literal

```js
// 변수에 함수 리터럴 할당
var foo = function add(x, y) {
  return x + y;
};
// 함수 리터럴은 함수 이름을 생략할 수 있다.
var foo = function (x, y) {
  return x + y;
};
```

| 구성 요소       | 설명                                                                                                                          |
| :-------------- | :---------------------------------------------------------------------------------------------------------------------------- |
| `함수 이름`     | 함수 이름은 식별자다. 따라서 식별자 네이밍 규칙을 준수해야 한다.                                                              |
|                 | 함수 이름은 `함수 몸체 내에서만 참조할 수 있는 식별자`다.                                                                     |
|                 | 함수 이름은 생략할 수 있다. 이름이 있는 함수를 기명 함수, 이름이 없는 함수를 무명/익명 함수라 한다.                           |
| `매개변수 목록` | 0개 이상의 매개변수를 소괄호로 감싸고 쉼표로 구분한다.                                                                        |
|                 | 각 매개변수에는 함수를 호출할 때 지정한 인수가 순서대로 할당된다. 즉, 매개변수 목록은 순서에 의미가 있다.                     |
|                 | 매개변수는 함수 몸체 내에서 변수와 동일하게 취급된다. 따라서 매개변수도 변수와 마찬가지로 식별자 네이밍 규칙을 준수해야 한다. |
| `함수 몸체`     | 함수가 호출되었을 때 일괄적으로 실행될 문들을 하나의 실행 단위로 정의한 코드 블록이다.                                        |
|                 | 함수 몸체는 `함수 호출에 의해 실행된다`.                                                                                      |

## Fucntion Declaration

```js
function add(x, y) {
  return x + y;
}
```

함수 선언문은 리터럴과 형태가 동의하다. 단, 함수 리터럴은 함수 이름을 생략할 수 있으나 `함수 선언문은 함수 이름을 생략할 수 없다.`
`함수 선언문은 표현식이 아닌 문이다.` 표현식이 아닌 문은 변수에 할당할 수 없다. 함수 선언문도 표현식이 아닌 문이므로 변수에 할당할 수 없으나 함수 선언문이 변수에 할당되는 것처럼 보인다.

```js
var add = function add(x, y) {
  return x + y;
};
console.log(add(2, 5));
```

이렇게 동작하는 이유는 자바스크립트 엔진이 코드 문맥에 따라 동일한 함수 리터럴을 1️⃣ **표현식이 아닌 문인 함수 선언문으로 해석하는 경우와** 2️⃣ **표현식인 문인 함수 티러럴 표현식으로 해석하는 경우**가 있기 때문이다.

1️⃣ 과 연계

- 함수 이름이 있는 함수 리터럴을 단독으로 사용하면 함수 선언문으로 해석

2️⃣ 와 연계

- 함수 리터럴이 값으로 평가되어야 하는 문맥, 예를 들어 함수 리터럴을 변수에 할당하거나 피연산자로 사용하면 함수 리터럴 표현식으로 해석한다.

```js
// 함수 선언문
function foo() {
  console.log("");
}
foo();

//함수 리터럴 표현식
(function bar() {
  console.log("");
});
bar(); // 동작 🚫
```

이름이 있는 기명 함수 리터럴은 코드 문맥에 따라 함수 선언문 또는 함수 리터럴 표현식으로 해석된다.
함수 이름은 함수 몸체 내부에서만 유효한 식별자이므로 함수 이름과는 별도로 생성된 함수 객체를 가리키는 식별자가 필요하다. 함수 객체를 가리키는 식별자가 없으면 생성된 함수 객체를 참조할 수 없으므로 호출할 수도 없다. `따라서 자바스크립트 엔진은 생성된 함수를 호출하기 위해 함수 이름과 동일한 식별자를 암묵적으로 생성하고, 거기에 함수 객체를 할당한다.`
`함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출한다.`
자바스크립트 엔진은 함수 선언문을 함수 표현식으로 변환해 함수 객체를 생성한다.

```js
var add = function add(x, y) {
  return x + y;
};
console.log(add(2, 5));
```

**함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출한다.**

## Function Expression

자바스크립트의 함수는 일급 객체다. 즉, 함수를 값처럼 자유롭게 사용할 수 있다.
함수 이름은 몸체 내부에서만 유효한 식별자이므로 함수 이름으로 함수를 호출할 수 없으며 함수 객체를 가리키는 식별자를 사용해야한다.

```js
var add = function foo(x, y) {
  return x + y;
};
// 함수 객체를 가리키는 식별자로 호출
console.log(add(2, 5));

// 함수 이름은 함수 몸체 내부에서만 유효한 식별자다.
console.log(foo(2, 5));
```

함수 선언문과 함수 표현식은 정확히 동일하게 동작하지 않는다.
함수 선언문은 `표현식이 아닌 문` 이고
함수 표현식은 `표현식인 문` 이다.

```js
console.dir(add); //add(x,y);
console.dir(sub); //undefined

console.log(add);
console.log(sub); // 동작 🚫

function add(x, y) {
  return x + y;
}

var sub = function (x, y) {
  return x - y;
};
```

**함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점은 다르다.**

1. 함수 선언문은 코드가 한 줄씩 순차적으로 실행되기 시작하는 런타임에는 이미 함수 객체가 생성되어 있고 함수 이름과 동일한 식별자에 할당까지 완료된 상태다.
   **함수 선언문이 코드의 선두로 끌어올려진 것처럼 동작하는 자바스크립트의 고유 특징을 함수 호이스팅이라 한다.**

2. 함수 표현식은 변수에 할당되는 값이 함수 리터럴인 문이다. 함수 표현식은 변수 선언문과 변수 할당문을 한 번에 기술한 축약 표현과 동일하게 동작한다. **변수 할당문의 값은 할당문이 실행되는 시점,즉 런타임에 평가되므로 함수 표현식의 함수 리터럴도 할당문이 실행되는 시점에 평가되어 함수 객체가 된다.**

따라서 `함수 표현식으로 함수를 정의하면 함수 호이스팅이 발생하는 것이 아니라 변수 호이스팅이 발생한다.`

## Callback Function

함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 콜백 함수`callback function` 라고 하며, 매개 변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수를 고차 함수`high-order function HOF`라고 한다.

함수 내부의 중첩 함수는 고정되어 있어서 교체하기 곤란하지만 콜백 함수는 외부에서 고차 함수 내부로 주입하기 때문에 자유롭게 교체할 수 있다는 장점이 있다.즉, **고차 함수는 콜백 함수를 자신의 일부분으로 합성한다.**
**고차 함수는 매개변수를 통해 전달받은 콜백 함수의 호출 시점을 결정해서 호출한다. 콜백 함수에 의해 호출되며 이때 고차 함수는 필요에 따라 콜백 함수에 인수를 전달할 수 있다.**

```js
// 익명 함수 리터럴은 콜백 함수로 고차 함수에 전달한다.
// 익명 함수 리터럴은 repeat 함수를 호춣할 때마다 평가되어 함수 객체를 생성한다.
repeat(5, function (i) {
  if (i % 2) console.log(i);
});
```

콜백 함수는 비동기 처리(이벤트 처리, Ajax 통신, 타이머 함수 등)에 활용되는 중요한 패턴이다.

## Pure & Inpure function

외부 상태에 의존하지 않고 변경하지도 않는, 즉 부수 효과가 없는 함수를 순수 함수라 하고, 반대를 비순수 함수라고 부른다.

순수 함수는 일반적으로 최소 하나 이상의 인수를 전달받는다. 순수함수는 불변성을 유지한다.
순수 함수의 또 하나의 특징은 함수의 외부 상태를 변경하지 않는다는 것이다.

```js
var count = 0;
function increase(n) {
  return ++n;
}

count = increase(count);
console.log(count); //1

count = increase(count);
console.log(count); //2
```
